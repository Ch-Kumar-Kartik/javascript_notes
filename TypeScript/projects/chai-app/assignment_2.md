# üçµ ChaiShop - TypeScript Practice Project

> A comprehensive hands-on project to practice every TypeScript concept from your learning journey

---

## üìã Project Overview

**Build a complete Chai Shop Management System** - a command-line application that manages a chai shop's inventory, orders, customers, and brewing operations.

### Objectives
- Apply all TypeScript concepts learned across 13 video tutorials
- Build a realistic, cohesive project that demonstrates type safety
- Practice structuring TypeScript code in a maintainable way
- Work with both compile-time and runtime type checking

---

## üìö Concepts Covered (Extracted from Your Files)

Based on my analysis of your learning files, here are **all the concepts** you need to demonstrate:

### Core Type System
| # | Concept | Source File |
|---|---------|-------------|
| 1 | Type Annotations | `01.ts`, `02_type_annotations_inference.ts` |
| 2 | Type Inference | `02_type_annotations_inference.ts` |
| 3 | Union Types | `03_union_any.ts` |
| 4 | Literal Types | `03_union_any.ts`, `06_type_interfce.ts` |
| 5 | `any` Type | `03_union_any.ts` |
| 6 | `unknown` Type | `04_type_narrowing_type_guards.ts`, `05_type_assertion_unkown_never.ts` |
| 7 | `never` Type | `05_type_assertion_unkown_never.ts` |
| 8 | Type Assertions (`as`) | `05_type_assertion_unkown_never.ts` |

### Type Narrowing & Guards
| # | Concept | Source File |
|---|---------|-------------|
| 9 | `typeof` Narrowing | `04_type_narrowing_type_guards.ts` |
| 10 | Truthiness Narrowing | `04_type_narrowing_type_guards.ts` |
| 11 | Equality Narrowing | `04_type_narrowing_type_guards.ts` |
| 12 | `in` Operator Narrowing | `04_type_narrowing_type_guards.ts` |
| 13 | `instanceof` Narrowing | `04_type_narrowing_type_guards.ts` |
| 14 | Discriminated Unions | `04_type_narrowing_type_guards.ts` |
| 15 | Custom Type Guards (`is` keyword) | `04_type_narrowing_type_guards.ts` |
| 16 | Exhaustiveness Checking | `04_type_narrowing_type_guards.ts`, `05_type_assertion_unkown_never.ts` |

### Types & Interfaces
| # | Concept | Source File |
|---|---------|-------------|
| 17 | Type Aliases | `06_type_interfce.ts`, `07_object_discussion.ts` |
| 18 | Interfaces | `06_type_interfce.ts`, `11_more_on_interfaces.ts` |
| 19 | `implements` Keyword | `06_type_interfce.ts` |
| 20 | Intersection Types (`&`) | `06_type_interfce.ts` |
| 21 | Optional Properties (`?`) | `06_type_interfce.ts`, `11_more_on_interfaces.ts` |
| 22 | Readonly Properties | `06_type_interfce.ts`, `11_more_on_interfaces.ts` |
| 23 | Index Signatures | `11_more_on_interfaces.ts` |
| 24 | Interface Extension (`extends`) | `11_more_on_interfaces.ts` |
| 25 | Interface Declaration Merging | `11_more_on_interfaces.ts` |
| 26 | Callable Interface (Function Type) | `11_more_on_interfaces.ts` |

### Object Types & Utility Types
| # | Concept | Source File |
|---|---------|-------------|
| 27 | Object Type Declaration | `07_object_discussion.ts` |
| 28 | Structural Typing | `07_object_discussion.ts` |
| 29 | Nested Object Types | `07_object_discussion.ts` |
| 30 | `Partial<T>` | `07_object_discussion.ts` |
| 31 | `Required<T>` | `07_object_discussion.ts` |
| 32 | `Pick<T, K>` | `07_object_discussion.ts` |
| 33 | `Omit<T, K>` | `07_object_discussion.ts` |

### Functions
| # | Concept | Source File |
|---|---------|-------------|
| 34 | Function Return Types | `01.ts`, `08_function.ts` |
| 35 | Function Parameter Types | `08_function.ts` |
| 36 | Optional Parameters | `08_function.ts` |
| 37 | Default Parameters | `08_function.ts` |
| 38 | `void` Return Type | `08_function.ts` |
| 39 | Complex Object Parameters | `08_function.ts` |
| 40 | Nullable Return (`string | null`) | `08_function.ts` |

### Arrays, Tuples & Enums
| # | Concept | Source File |
|---|---------|-------------|
| 41 | Typed Arrays (`string[]`, `Array<T>`) | `09_array_enum_tuples.ts` |
| 42 | Array of Objects | `09_array_enum_tuples.ts` |
| 43 | Readonly Arrays | `09_array_enum_tuples.ts` |
| 44 | Multi-dimensional Arrays | `09_array_enum_tuples.ts` |
| 45 | Tuples | `09_array_enum_tuples.ts` |
| 46 | Optional Tuple Elements | `09_array_enum_tuples.ts` |
| 47 | Named Tuple Elements | `09_array_enum_tuples.ts` |
| 48 | Readonly Tuples | `09_array_enum_tuples.ts` |
| 49 | Numeric Enums | `09_array_enum_tuples.ts` |
| 50 | String Enums | `09_array_enum_tuples.ts` |
| 51 | Const Enums | `09_array_enum_tuples.ts` |
| 52 | Enum Auto-increment | `09_array_enum_tuples.ts` |

### Object-Oriented Programming
| # | Concept | Source File |
|---|---------|-------------|
| 53 | Classes & Constructors | `10_oops.ts` |
| 54 | `public` Access Modifier | `10_oops.ts` |
| 55 | `private` Access Modifier | `10_oops.ts` |
| 56 | `protected` Access Modifier | `10_oops.ts` |
| 57 | Private Fields (`#`) | `10_oops.ts` |
| 58 | `readonly` Class Properties | `10_oops.ts` |
| 59 | Getters and Setters | `10_oops.ts` |
| 60 | Static Members | `10_oops.ts` |
| 61 | Abstract Classes | `10_oops.ts` |
| 62 | Class Inheritance (`extends`) | `10_oops.ts` |
| 63 | Composition over Inheritance | `10_oops.ts` |

### Generics
| # | Concept | Source File |
|---|---------|-------------|
| 64 | Generic Functions | `12_generics.ts` |
| 65 | Multiple Type Parameters | `12_generics.ts` |
| 66 | Generic Interfaces | `12_generics.ts` |
| 67 | Generic Return Types | `12_generics.ts` |

### Async & External Libraries
| # | Concept | Source File |
|---|---------|-------------|
| 68 | Type Declaration Files (`.d.ts`) | `13_type_definations_axios.ts` |
| 69 | Importing Types | `13_type_definations_axios.ts` |
| 70 | Async/Await with Types | `13_type_definations_axios.ts` |
| 71 | Typed HTTP Responses | `13_type_definations_axios.ts` |
| 72 | Error Handling with Types | `05_type_assertion_unkown_never.ts`, `13_type_definations_axios.ts` |

---

## üéØ Project Tasks

### Phase 1: Core Data Models (Tasks 1-4)

#### Task 1: Create Base Types & Enums
**File:** `src/types/enums.ts`

Create the following enums:
```typescript
// TODO: Create these enums
// - ChaiSize: SMALL, MEDIUM, LARGE (numeric enum with auto-increment starting at 1)
// - OrderStatus: PENDING = "pending", PREPARING = "preparing", SERVED = "served", CANCELLED = "cancelled" (string enum)
// - PaymentMethod: CASH, CARD, UPI (const enum)
// - ChaiCategory: MASALA, GINGER, LEMON, ELAICHI, ADRAK (string enum)
```

**Concepts tested:** `#49, #50, #51, #52`

---

#### Task 2: Define Core Interfaces
**File:** `src/types/interfaces.ts`

```typescript
// TODO: Create interfaces with the following requirements:

// 1. Ingredient interface with:
//    - name: string
//    - quantity: number
//    - unit: string (grams, ml, pieces)

// 2. ChaiRecipe interface with:
//    - readonly id: string
//    - name: string
//    - category: ChaiCategory (from enums)
//    - ingredients: Ingredient[]
//    - prepTimeMinutes: number
//    - secretIngredient?: string (optional)

// 3. Customer interface with:
//    - id: number (readonly)
//    - name: string
//    - phone?: string (optional)
//    - [key: string]: unknown (index signature for extra data)

// 4. ChaiOrder interface with:
//    - orderId: string
//    - items: tuple of [ChaiCategory, ChaiSize, number (quantity)]
//    - customer: Customer
//    - status: OrderStatus
//    - paymentMethod: PaymentMethod
//    - timestamp: Date
//    - specialInstructions?: string

// 5. Create an interface OrderSummary that extends ChaiOrder
//    - Add: totalPrice: number, preparationTime: number
```

**Concepts tested:** `#18, #21, #22, #23, #24, #45`

---

#### Task 3: Create Type Aliases & Utility Types
**File:** `src/types/aliases.ts`

```typescript
// TODO: Create these type aliases:

// 1. ChaiName - literal union type of chai names ("Masala Chai" | "Ginger Tea" | "Lemon Tea" | "Elaichi Chai" | "Adrak Chai")

// 2. Price - type alias for number

// 3. ChaiMenuItem - object type with name, price, isHot (boolean), and ingredients (string[])

// 4. CreateOrderInput - use Omit<> to create a type from ChaiOrder without 'orderId', 'status', and 'timestamp'

// 5. UpdateOrderInput - use Partial<> on ChaiOrder

// 6. OrderDisplay - use Pick<> to select only 'orderId', 'status', 'totalPrice' from OrderSummary

// 7. InventoryItem - intersection type combining { itemName: string } & { stock: number } & { threshold: number }

// 8. ApiResponse<T> - generic type with status: number, data: T, error?: string
```

**Concepts tested:** `#4, #17, #20, #27, #30, #31, #32, #33, #66`

---

#### Task 4: Implement Type Guards
**File:** `src/utils/typeGuards.ts`

```typescript
// TODO: Implement these type guard functions:

// 1. isChaiOrder - custom type guard using `is` keyword to check if unknown value is ChaiOrder
//    - Check for orderId (string), items (array), customer (object), status (OrderStatus value)

// 2. isValidCustomer - custom type guard checking for valid Customer shape

// 3. isStringArray - checks if unknown value is string[]

// 4. narrowOrderStatus - function that takes status: string | OrderStatus
//    - Use typeof narrowing to handle the cases

// 5. processPayment - function with PaymentMethod | string parameter
//    - Use in operator to narrow the type

// 6. Create a discriminated union type:
//    type ChaiEvent = 
//      | { type: "order_placed"; orderId: string; customer: Customer }
//      | { type: "order_prepared"; orderId: string; timeInMinutes: number }
//      | { type: "order_cancelled"; orderId: string; reason: string }
//    
//    Then create handleChaiEvent function with exhaustive switch statement
```

**Concepts tested:** `#9, #10, #11, #12, #14, #15, #16`

---

### Phase 2: Class Implementation (Tasks 5-8)

#### Task 5: Create Abstract Beverage Class
**File:** `src/models/Beverage.ts`

```typescript
// TODO: Create an abstract class Beverage with:

// Protected properties:
//   - _name: string
//   - _basePrice: number
//   - _temperature: "hot" | "cold"

// Constructor that takes name and basePrice

// Abstract methods:
//   - abstract make(): string
//   - abstract calculatePrice(size: ChaiSize): number

// Concrete methods:
//   - describe(): string - returns description
//   - Getters for name, basePrice, temperature

// Static property:
//   - static readonly SHOP_NAME = "ChaiCode Cafe"
```

**Concepts tested:** `#53, #56, #58, #59, #60, #61`

---

#### Task 6: Implement Chai Class with Inheritance
**File:** `src/models/Chai.ts`

```typescript
// TODO: Create a Chai class that:

// 1. Extends Beverage abstract class
// 2. Implements ChaiRecipe interface

// Private properties (use # syntax for at least one):
//   - #secretIngredient: string
//   - private _sugar: number (use getter/setter with validation max 5)
//   - private ingredients: Ingredient[]

// Public properties:
//   - readonly id: string
//   - category: ChaiCategory

// Constructor:
//   - Use parameter properties shorthand (public/private in constructor)
//   - Initialize with ChaiRecipe data

// Implement abstract methods:
//   - make(): string
//   - calculatePrice(size: ChaiSize): number

// Additional methods:
//   - addIngredient(ingredient: Ingredient): void
//   - getSecretIngredient(): string (reveal the private field)
```

**Concepts tested:** `#19, #53, #54, #55, #57, #59, #62`

---

#### Task 7: Create Order Manager with Composition
**File:** `src/models/OrderManager.ts`

```typescript
// TODO: Create supporting classes and main OrderManager:

// 1. PriceCalculator class:
//    - method: calculate(items: ChaiOrder['items']): number

// 2. OrderValidator class:
//    - method: validate(order: unknown): order is ChaiOrder

// 3. OrderManager class (uses composition):
//    - Private properties:
//      - orders: ChaiOrder[] (readonly array)
//      - priceCalculator: PriceCalculator
//      - validator: OrderValidator
//    
//    - Constructor receives calculator and validator (dependency injection)
//    
//    - Methods:
//      - createOrder(input: CreateOrderInput): OrderSummary
//      - updateOrder(orderId: string, updates: UpdateOrderInput): ChaiOrder | null
//      - getOrder(orderId: string): ChaiOrder | undefined
//      - getOrdersByStatus(status: OrderStatus): readonly ChaiOrder[]
//      - cancelOrder(orderId: string, reason: string): boolean
```

**Concepts tested:** `#40, #43, #63`

---

#### Task 8: Implement Generic Repository
**File:** `src/models/Repository.ts`

```typescript
// TODO: Create a generic Repository class:

// 1. Generic interface Identifiable<T>:
//    - id: T

// 2. Generic class Repository<T extends Identifiable<string | number>>:
//    - Private items: T[] array
//    
//    - Methods:
//      - add(item: T): T
//      - getById(id: T['id']): T | undefined
//      - getAll(): readonly T[]
//      - update(id: T['id'], updates: Partial<T>): T | undefined
//      - delete(id: T['id']): boolean
//      - find(predicate: (item: T) => boolean): T[]

// 3. Create specialized repositories:
//    - CustomerRepository extends Repository<Customer>
//    - OrderRepository with custom OrderSummary handling

// 4. Generic function:
//    - wrapInResponse<T>(data: T, status: number): ApiResponse<T>
```

**Concepts tested:** `#64, #65, #66, #67`

---

### Phase 3: Advanced Features (Tasks 9-11)

#### Task 9: Create Menu System with Arrays & Tuples
**File:** `src/services/MenuService.ts`

```typescript
// TODO: Implement MenuService with:

// 1. Define types:
//    - MenuItemTuple: [name: string, price: number, available: boolean]
//    - PriceMatrix: number[][] (2D array for size x category pricing)

// 2. Class MenuService:
//    Private properties:
//      - menuItems: readonly ChaiMenuItem[]
//      - priceMatrix: PriceMatrix
//      - ratings: { [chaiName: string]: number[] } (index signature for ratings)
//    
//    Methods:
//      - getMenuItem(name: ChaiName): ChaiMenuItem | undefined
//      - addRating(chai: ChaiName, rating: number): void
//      - getAverageRating(chai: ChaiName): number
//      - getMenuAsTuples(): readonly MenuItemTuple[]
//      - getPriceByMatrixPosition(sizeIndex: number, categoryIndex: number): number

// 3. Use tuple destructuring in methods where appropriate
```

**Concepts tested:** `#41, #42, #43, #44, #45, #47, #48, #23`

---

#### Task 10: Async Data Service with Type Assertions
**File:** `src/services/DataService.ts`

```typescript
// TODO: Create DataService for simulated API calls:

// 1. Define response interfaces:
//    interface ChaiApiResponse {
//      id: string;
//      name: string;
//      category: string;
//      // ... other fields
//    }

// 2. Class DataService:
//    Methods:
//      - async fetchChaiMenu(): Promise<ChaiMenuItem[]>
//        - Simulate API call with setTimeout
//        - Use type assertion on parsed JSON
//        - Handle unknown response data
//      
//      - async fetchOrderById(id: string): Promise<ChaiOrder | null>
//        - Use type assertions carefully
//        - Implement proper error handling with typed catch
//      
//      - async saveOrder(order: ChaiOrder): Promise<ApiResponse<{orderId: string}>>
//        - Return proper generic response
//      
//      - parseUnknownResponse(data: unknown): ChaiMenuItem | null
//        - Use type guards to safely parse unknown data
//        - Use `as` assertion only after validation

// 3. Error handling:
//    - Create custom error types
//    - Use try-catch with proper type narrowing on error
//    - Demonstrate never type for exhaustive error handling
```

**Concepts tested:** `#6, #7, #8, #70, #71, #72`

---

#### Task 11: Build the Main Application
**File:** `src/app.ts`

```typescript
// TODO: Create the main application that ties everything together:

// 1. Initialize all services and repositories

// 2. Create sample data using all your types

// 3. Demonstrate each concept through practical usage:
//    - Create customers with optional properties
//    - Create chai items using type inference
//    - Process orders through the OrderManager
//    - Use the generic repository
//    - Make async calls to DataService
//    - Handle various order events (discriminated union)

// 4. Create a processCommand function:
//    - Takes command: "order" | "cancel" | "status" | "menu" | "exit"
//    - Uses switch with exhaustiveness check
//    - Returns appropriate messages

// 5. Implement printOrder function:
//    - Takes order: ChaiOrder | string (union)
//    - Use type narrowing to handle both cases
//    - Call your custom type guard

// 6. Run the application with console output showing the type safety in action
```

**Concepts tested:** `#1, #2, #3, #16, #37, #38, #39`

---

## üó∫Ô∏è Concept Mapping

| Task | Concepts Covered |
|------|------------------|
| Task 1 | Numeric Enums, String Enums, Const Enums, Auto-increment |
| Task 2 | Interfaces, Optional Properties, Readonly, Index Signatures, Interface Extension, Tuples |
| Task 3 | Literal Types, Type Aliases, Intersection Types, Object Types, Partial, Required, Pick, Omit, Generic Interfaces |
| Task 4 | typeof, Truthiness, Equality, in Operator Narrowing, Discriminated Unions, Custom Type Guards, Exhaustiveness |
| Task 5 | Classes, Protected, Readonly, Getters/Setters, Static, Abstract |
| Task 6 | Implements, Public, Private, Private Fields (#), Getters/Setters, Inheritance |
| Task 7 | Nullable Returns, Readonly Arrays, Composition |
| Task 8 | Generic Functions, Multiple Type Params, Generic Interfaces, Generic Return Types |
| Task 9 | Typed Arrays, Object Arrays, Readonly Arrays, 2D Arrays, Tuples, Named Tuples, Readonly Tuples, Index Signatures |
| Task 10 | Unknown, Never, Type Assertions, Async/Await Types, HTTP Response Types, Error Handling |
| Task 11 | Annotations, Inference, Union Types, Exhaustiveness, Default Params, Void, Complex Object Params |

---

## üèÜ Bonus Challenges

### Bonus 1: Type-Safe Event System
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê

Create a fully type-safe event emitter system:

```typescript
// Requirements:
// 1. Define event map with specific payload types for each event name
// 2. Create generic EventEmitter<T extends EventMap> class
// 3. emit<K extends keyof T>(event: K, payload: T[K]): void
// 4. on<K extends keyof T>(event: K, handler: (payload: T[K]) => void): void
// 5. Implement with proper type inference so handlers know exact payload type

type ChaiShopEvents = {
  orderPlaced: { orderId: string; customer: Customer };
  orderReady: { orderId: string; chaiName: string };
  paymentReceived: { amount: number; method: PaymentMethod };
  shopClosed: never; // Event with no payload
};
```

**Concepts combined:** Generics, keyof, Mapped Types, never, Type Inference

---

### Bonus 2: Builder Pattern with Method Chaining
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

Implement a type-safe builder for ChaiOrder:

```typescript
// Requirements:
// 1. Each method should return 'this' for chaining
// 2. Build method should only be callable when all required fields are set
// 3. Use conditional types to track which fields have been set
// 4. Compile-time error if build() called before all required fields are provided

// Usage should look like:
const order = ChaiOrderBuilder
  .create()
  .withCustomer(customer)     // Required
  .withItems(items)           // Required
  .withPayment(method)        // Required
  .withSpecialInstructions()  // Optional
  .build();                   // Only compiles if all required set
```

**Concepts combined:** Generics, Conditional Types, Method Chaining, Compile-time Safety

---

### Bonus 3: Type-Safe API Client
**Difficulty:** ‚≠ê‚≠ê‚≠ê‚≠ê

Build a typed API client using generics and mapped types:

```typescript
// Requirements:
// 1. Define API endpoints with their request/response types
// 2. Create client where method autocomplete shows available endpoints
// 3. Request and response types should be inferred from endpoint

type ApiEndpoints = {
  '/orders': { GET: ChaiOrder[]; POST: { body: CreateOrderInput; response: OrderSummary } };
  '/orders/:id': { GET: ChaiOrder; PUT: { body: UpdateOrderInput; response: ChaiOrder } };
  '/menu': { GET: ChaiMenuItem[] };
  '/customers/:id': { GET: Customer };
};

// Usage:
const client = new ApiClient<ApiEndpoints>();
const orders = await client.get('/orders'); // Type: ChaiOrder[]
const order = await client.post('/orders', body); // Type: OrderSummary
```

**Concepts combined:** Generics, Mapped Types, Template Literal Types, Async, Type Inference

---

## üìÅ Starter Template

Create this folder structure and files to begin:

```
chai-shop/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ enums.ts          # Task 1
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces.ts     # Task 2
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aliases.ts        # Task 3
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ typeGuards.ts     # Task 4
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Beverage.ts       # Task 5
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Chai.ts           # Task 6
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderManager.ts   # Task 7
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Repository.ts     # Task 8
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MenuService.ts    # Task 9
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataService.ts    # Task 10
‚îÇ   ‚îî‚îÄ‚îÄ app.ts                # Task 11
‚îî‚îÄ‚îÄ README.md
```

### `package.json`
```json
{
  "name": "chai-shop",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "dev": "bun run src/app.ts",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

### `tsconfig.json`
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "exactOptionalPropertyTypes": true
  },
  "include": ["src/**/*"]
}
```

---

## ‚úÖ Completion Checklist

Use this to track your progress:

### Phase 1: Core Data Models
- [ ] Task 1: Enums created and working
- [ ] Task 2: All interfaces defined
- [ ] Task 3: Type aliases with utility types
- [ ] Task 4: Type guards implemented

### Phase 2: Class Implementation
- [ ] Task 5: Abstract Beverage class
- [ ] Task 6: Chai class with inheritance
- [ ] Task 7: OrderManager with composition
- [ ] Task 8: Generic Repository

### Phase 3: Advanced Features
- [ ] Task 9: Menu system with arrays/tuples
- [ ] Task 10: Async data service
- [ ] Task 11: Main application

### Bonus Challenges
- [ ] Bonus 1: Event System
- [ ] Bonus 2: Builder Pattern
- [ ] Bonus 3: API Client

---

## üí° Tips for Success

1. **Enable strict mode** - The `tsconfig.json` above enables strict mode. Don't disable it!

2. **Let TypeScript help you** - Hover over variables to see inferred types. Use this to learn.

3. **Build incrementally** - Complete each task before moving to the next. Tasks build on each other.

4. **Run typecheck often** - Use `npm run typecheck` to catch errors early.

5. **Reference your notes** - Your original learning files are the answer key. Consult them when stuck.

---

Good luck! üçµ Build something amazing with TypeScript!
